<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>Documentacao tecnica</title>
</head>

<body>
  <header id="main-header">
    <nav id="navbar">
      <h1>devSocial documentacao</h1>
      <ul>
        <li class="nav-link"><a href="#introduction">Introducao</a></li>
        <li class="nav-link"><a href="#Articles">Articles</a> </li>
        <li class="nav-link"><a href="#Comments">Comments</a></li>
        <li class="nav-link"><a href="#Contacts">Contatcts</a></li>
        <li class="nav-link"><a href="#social">Social</a></li>
        <li class="nav-link"><a href="#Team">Team</a></li>
        <li class="nav-link"><a href="#Topicos">Topicos</a></li>
        <li class="nav-link"><a href="#contatos">Contatos</a></li>
        <li class="nav-link"><a href="#mensagens">Mensagens</a></li>
        <li class="nav-link"><a href="#usuarios">Usuario</a></li>
        <li class="nav-link"><a href="#ferramentas">Ferramentas usadas</a></li>
      </ul>
    </nav>
  </header>
  <main id="main-doc">
    <section class="main-section" id="introduction">
      <header>Introduction</header>
      <article class="main-article">
        <p>somos a devSocial XXXXXXXXXX</p>
        <p>XXXXXXXXX</p>
        <ul>
          <p>XXXXXXXXX</p>
        </ul>
      </article>
    </section>

    <section class="main-section" id="Articles">
      <header>Articles Controller</header>
      <article class="main-article">
        <p>ArticleController é a classe principal neste pacote com os seguintes Métodos e endpoints:</p>
        <ul>
          
          <u><hr>Método getAll: GET /articles</u>
          <p>Este método retorna uma lista de todos os artigos. Ele realiza uma chamada ao método findAllValidArticles() do repositório de artigos (ArticleRepository) para recuperar os artigos e os retorna como resposta. Esse endpoint retorna uma lista de todos os artigos que são considerados válidos. São como pequenos textos sobre diferentes assuntos. </p>
<u>
    <hr>Método getOne:  GET /articles/{id}:
</u>
<p>Este método retorna um único artigo válido com base no ID fornecido. O ID do artigo por exemplo é passado assim:  <code>urldaApi/articles/1</code>: O método chama o método findArticleById(id) do repositório de artigos e retorna o artigo correspondente com o id 1.</p>
<u>
    <hr>Método getByViews: GET /articles/views/{limit}
</u>
<p>Com esse endpoint, você pode pedir à API para mostrar uma lista dos artigos mais populares, os artigos que mais foram vistos pelos usuarios. Você pode especificar quantos artigos deseja ver usando o parâmetro {limit}. por exemplo, se deseja ver apenas 3 artigos dos mais vistos o endpoint ficara assim: <code>urldaApi/articles/views/3</code></p>

<u>
    <hr>Método updateViews:  PATCH /articles/{id}:
</u>
<p>
    Este método atualiza o número de visualizações de um artigo com base no ID fornecido. O ID do artigo é passado como um parâmetro de caminho na URL da requisição. por exemplo: <code>Patch urldaApi/articles/1</code> O método chama o método updateViews(id) do repositório de artigos para realizar a atualização do artigo com o id 1.
</p>
<u><hr>Método getByAuthor: GET /articles/author</u>
<p>Este método retorna uma lista de artigos do autor com base nos parâmetros fornecidos. Os parâmetros uid, art e lim são passados como parâmetros de consulta na URL da requisição. O método chama o método findAllByAuthor(uid, articleId, limit) do repositório de artigos para recuperar os artigos correspondentes e os retorna como resposta</p>
        </ul>
      </article>
    </section>

    <section class="main-section" id="Comments">
      <header>Comments Controller</header>
      <article class="main-article">
        <p>
            CommentController é a classe principal neste pacote e possui os seguintes métodos e endpoints:</p>
            <hr><u>Método getLast: GET /comments/last/{limite} </u>:
            <p> Este método retorna uma lista dos últimos comentários com base no limite fornecido. se você quiser por exemplo pegar os 3 ultimos comentários, a requisição a api ficara assim: <code>urldaApi/comments/last/3</code>. O método chama o método findLastComments(limit) do repositório de comentários (CommentRepository) para recuperar os comentários correspondentes.</p>
        
          <hr><u>Método getAll: GET /comments/{idDoArtigo}</u>
          <p>
            Este método retorna uma lista de todos os comentários de um determinado artigo com base no ID fornecido. se você quiser por exemplo pegar todos os comentários do artigo do id 5, a requisição a api ficara assim: <code>urldaApi/comments/5</code>. O método chama o método findAllCommentByArticle(articleId) do repositório de comentários e retorna os comentários correspondentes. 
          </p>

          <hr><u>Método postComment: POST /comments</u>
<p>Usando este endpoint, você pode enviar um novo comentário. O método chama o método save(comment) do repositório de comentários para salvar o novo comentário no banco de dados.  </p>
      </article>
    </section>

    <section class="main-section" id="Contacts">
      <header>Contacts Controller</header>
      <article class="main-article">
        <p>ContactController é a classe principal neste pacote e possui o seguinte método:</p>
        <hr><u>Método saveContact: POST /contact</u>
        <p>Este método permite salvar o formulário de contato do usuário. O método chama o método save(contact) do repositório de contatos (ContactRepository) para salvar o novo formulário de contato do usuário no banco de dados. </p>
      </article>
    </section>

    <section class="main-section" id="social">
      <header>Social Controller</header>
      <article class="main-article">
        <p>YSocialController é a classe principal neste pacote e possui o seguinte endpoint:</p>
        <u>Método getSocial: GET /users/social/{idDoUsuario} </u>
        <p>Este método retorna uma lista das informações sociais de um usuário específico com base no ID do usuário fornecido. por exemplo, se você quiser pegar as informações do user com id 12, a requisição a api ficara assim: <code>urldaApi/users/social/12</code> A API irá retornar as informações sociais desse usuário.</p>
      </article>
    </section>

    <section class="main-section" id="Team">
      <header>Team Controller</header>
      <article class="main-article">
        <p>TeamController é a classe principal neste pacote e possui os seguintes métodos e endpoints:</p>
       <hr> <u>Método getUser: GET /users/{id}</u>
        <p>Este método retorna as informações de um usuário específico com base no ID do usuário fornecido. O ID do usuário é passado como um parâmetro de caminho na URL da requisição. O método verifica se o registro com o ID fornecido existe no repositório de equipe (TeamRepository). Se o registro existir, as informações do usuário são retornadas. Caso contrário, será retornado null.</p>
        
       <hr><u>Método getAll: GET /users </u>
       <p>Aqui, você pode obter uma lista de todos os usuários. É como ter uma lista de todas as pessoas da equipe. A API irá retornar uma lista com as informações de cada usuário.</p>
      </article>
    </section>

    <section class="main-section" id="Topicos">
      <header>Topicos Controller</header>
      <article class="main-article">
        <p>topicosController é a classe principal neste pacote com os seguintes Métodos e endpoints:</p>
    
          
          <u><hr>Método getAll: GET /topicos</u>
          <p>Este método retorna uma lista de todos os topicos. Ele realiza uma chamada ao método findAllTopicos() do repositório de artigos (topicoRepository) para recuperar os artigos e os retorna como resposta. Esse endpoint retorna uma lista de todos os topicos. São como pequenos textos sobre diferentes assuntos. </p>
<u>
    <hr>Método getOne:  GET /articles/{id}:
</u>
<p>Este método retorna um único topico válido com base no ID fornecido. O ID do artigo por exemplo é passado assim:  <code>urldaApi/topicos/1</code>: O método chama o método findTopicosById(id) do repositório de artigos e retorna o artigo correspondente com o id 1.</p>
<u>
    <hr>Método getByViews: GET /topicos/views/{limit}
</u>
<p>Com esse endpoint, você pode pedir à API para mostrar uma lista dos topicos mais populares, os topicos que mais foram vistos pelos usuarios. Você pode especificar quantos topicos deseja ver usando o parâmetro {limit}. por exemplo, se deseja ver apenas 3 artigos dos mais vistos o endpoint ficara assim: <code>urldaApi/topicos/views/3</code></p>

<u>
    <hr>Método updateViews:  PATCH /topicos/{id}:
</u>
<p>
    Este método atualiza o número de visualizações de um topico com base no ID fornecido. O ID do topico é passado como um parâmetro de caminho na URL da requisição. por exemplo: <code>Patch urldaApi/topico/1</code> O método chama o método updateViews(id) do repositório de topicos para realizar a atualização do artigo com o id 1.
</p>
      </article>
    </section>

    <section class="main-section" id="contatos">
      <header>Contatos</header>
      <article class="main-article">
        <p>ContatosController é a classe principal neste pacote com os seguintes Métodos e endpoints:</p></p>
       <hr>  <u>GET /contatosadicionados/{uId}</u>
        <p>Este endpoint retorna uma lista de contatos adicionados por um determinado usuário. Ela recebe um parâmetro de caminho chamado uId, que representa o ID do usuário. A função correspondente a esta rota chama o método listaCont do objeto contatosAdicionadosRepository, que retorna uma lista de contatos adicionados pelo usuário especificado.</p>
        <code>GET urldaApi/contatosadicionados/1</code>
<p>a api irá retornar o contato adicionado onde tem o id 1</p>

<hr><u>GET /contatosadicionados/{uId1}/{uId2}</u>
<p>Esta rota verifica se um determinado contato foi adicionado por um usuário. Ela recebe dois parâmetros de caminho: uId1 e uId2, que representam os IDs dos usuários. A função correspondente a esta rota chama o método existId do objeto contatosAdicionadosRepository, que verifica se o contato foi adicionado pelo usuário e retorna o objeto ContatosAdicionados correspondente, se existir. Exemplo:</p>
<code>GET urldaApi/contatosadicionados/1/2</code>
<p>a api irá responder se tem alguma relação entre o usuário de id 1 e 2</p>

<hr><u> POST /contatosadicionados</u>
<p>Esta rota permite adicionar um novo contato. Ela recebe os dados do contato no corpo da requisição. A função correspondente a esta rota chama o método save do objeto contatosAdicionadosRepository para salvar o novo contato no banco de dados e retorna o objeto ContatosAdicionados recém-adicionado. Exemplo:</p>
<code>POST urldaApi/contatosadicionados

    {
      "userId1": 1,
      "userId2": 2,
      "status": "amigo"
    }</code>
      </article>
    </section>

    <section class="main-section" id="mensagens">
      <header>Mensagens Controller</header>
      <article class="main-article">
        <p>MensagensController é a classe principal neste pacote com os seguintes Métodos e endpoints:</p>
       <h2></h2> <u>GET /mensagens/{uId1}/{uId2}</u>
        <p>Este endpoint retorna todas as mensagens entre dois usuários específicos. Ela recebe dois parâmetros de caminho: uId1 e uId2, que representam os IDs dos usuários. A função correspondente a este endpoint chama o método conversa do objeto mensagensRepository, que retorna uma lista de mensagens entre os dois usuários. por exemplo, se você fizer esta requisição a api:<code>GET urldaApi/mensagens/1/2</code>   a api irá retornar todas as mensagens dosusuários com id 1 e 2</p>

        <hr><u>GET /mensagens/{mens}/met/var/</u>
<p>Este endpoint retorna todas as mensagens que contenham uma determinada palavra. Ela recebe um parâmetro de caminho chamado mens, que representa a palavra a ser pesquisada. A função correspondente a este endpoint chama o método sendPPalavra do objeto mensagensRepository, que retorna uma lista de mensagens que correspondem à palavra-chave. Por exemplo, se o usuário fizer uma pesquisa nas mensagens, a requisição a a api sera feita assim:</p>
<code>GET urldaApi/mensagens/olá/met/var/</code>
<p>a api irá retornar todas as mensagens que contem a palavra olá</p>

<hr><u> GET /mensagens/{uId1}/{uId2}/nlidas</u>
<p>Este endpoint retorna todas as mensagens não lidas entre dois usuários específicos. Ela recebe dois parâmetros de caminho: uId1 e uId2, que representam os IDs dos usuários. A função correspondente a este endpoint chama o método mensagNLida do objeto mensagensRepository, que retorna uma lista de mensagens não lidas entre os dois usuários. por exemplo, se você fizer esta requisição a api:</p>
<code>GET urldaApi/mensagens/1/2/nlidas</code>
<p>a api irá retornar todas as mensagens não lidas entre os usuários de id 1 e 2  </p>

<hr><u>GET /mensagens/{mensId}</u>
<p>Este endpoint retorna uma única mensagem com base em seu ID. Ela recebe um parâmetro de caminho chamado mensId, que representa o ID da mensagem desejada. A função correspondente a esta rota verifica se a mensagem com o ID fornecido existe no repositório e retorna a mensagem, caso exista. por exemplo, se você fizer esta requisição a api:</p>
<code>GET urldaApi/mensagens/12</code>
<p>a api irá retornar a mensagem com id 12</p>


<hr><u>POST /mensagens</u>
<p>Este endpoint permite criar uma nova mensagem. Ela recebe os dados da mensagem no corpo da requisição, usando o formato JSON. A função correspondente a esta rota chama o método save do objeto mensagensRepository para salvar a nova mensagem no banco de dados e retorna a mensagem recém-criada. exemplo:</p>
<code>POST urldaApi/mensagens
    {
      "conteudo": "Olá, como você está?",
      "remetente": "Ermenilda",
      "destinatario": "Joca"
    }</code>

 <hr><u>PATCH /mensagens/{mensId}</u>
 <p>Este endpoint permite atualizar uma mensagem existente. Ela recebe o ID da mensagem a ser atualizada no parâmetro de caminho mensId e os dados atualizados no corpo da requisição, usando o formato JSON. A função correspondente a esta rota chama o método patch do objeto mensagensRepository para atualizar a mensagem com os dados fornecidos e retorna a mensagem atualizada. Exemplo:</p>
<code>PATCH /mensagens/12
    {
      "conteudo": "Estou bem, obrigado!",
      "remetente": "Bob",
      "destinatario": "Alice"
    }</code>
<p>a api irá atualizar o conteudo da mensagem</p>
      </article>
    </section>

    <section class="main-section" id="usuarios">
      <header>Usuario Controller</header>
      <article class="main-article">
        <p>UsuarioController é a classe principal neste pacote com os seguintes Métodos e endpoints:</p>
        <hr><u>GET /usuarios/{uNom}</u>
        <p> Este endpoint retorna uma lista de usuários com base em um nome de usuário específico. Ela recebe um parâmetro de caminho chamado uNom, que representa o nome de usuário a ser pesquisado. A função correspondente a esta rota chama o método listaPAdd do objeto usuarioRepository, que retorna uma lista de usuários que correspondem ao nome fornecido. exemplo:</p>
        <code>GET urldaApi/usuarios/joca</code>
        <p>a api irá retornar o usuário com o nome "Joca</p>

<hr><u> GET /usuarios/{userId}/one</u>
<p>Este endpoint retorna um único usuário com base em seu ID que é fornecido atraves do firebase . Ela recebe um parâmetro de caminho chamado userId, que representa o ID do usuário desejado. A função correspondente a esta rota chama o método sendUser do objeto usuarioRepository, que retorna o usuário com o ID fornecido. exemplo de requisição:</p>
<code>GET /usuarios/12/one</code>
<p>a api irá retornar o usuario com o id 12</p>

<hr><u> POST /usuarios</u>
<p>Este endpoint permite criar um novo usuário. Ela recebe os dados do usuário no corpo da requisição, usando o formato JSON. A função correspondente a esta rota chama o método save do objeto usuarioRepository para salvar o novo usuário no banco de dados e retorna o usuário recém-criado. exemplo:</p>
<code>POST urldaApi/usuarios
    {
      "nome": "joca",
      "idade": 30,
      "email": "joao@example.com"
    }</code>

<hr><u> PATCH /usuarios/{userId}</u>
<p>Este endpoint permite atualizar as informações de um usuário existente. Ela recebe o ID do usuário a ser atualizado no parâmetro de caminho userId e os dados atualizados no corpo da requisição, usando o formato JSON. A função correspondente a esta rota chama o método patch do objeto usuarioRepository para atualizar o usuário com os dados fornecidos e retorna o usuário atualizado. exemplo de requisição:</p>
<code>PATCH urldaApi/usuarios/123
    {
      "nome": "joca Silva",
      "idade": 35,
      "email": "joao.silva@example.com"
    }</code>

      </article>
    </section>

    <section class="main-section" id="ferramentas">
      <header>Ferramentas usadas</header>
      <article class="main-article">
        <ul>
            <u>Framework</u>
            <li>Spring-boot</li>
            <hr><u>annotations</u>
            <li>@RestController: Essa anotação marca a classe como um controlador REST, indicando que ela responderá a requisições HTTP e retornará dados no formato apropriado.</li>
           <li> @RequestMapping("/{rota}"): Essa anotação especifica o mapeamento de URL base para todas as rotas definidas dentro do controlador. Todas as rotas em cada controlador começarão com /{rota}.</li>
           <li> @CrossOrigin: Essa anotação permite solicitações de origens diferentes, permitindo acesso a partir de domínios externos.</li>
            <hr>    <u>Dependências</u>
        <li>spring-boot-starter-data-jpa: Dependência para o Spring Data JPA, que facilita a interação com o banco de dados por meio de objetos Java.</li>
        <li>spring-boot-starter-web: Dependência para o Spring Web, que fornece recursos para criar aplicativos web RESTful.</li>
        <li>h2: Dependência para o H2 Database, um banco de dados em memória usado para desenvolvimento e teste.</li>
        <li>lombok: Dependência opcional para o Lombok, uma biblioteca que ajuda a reduzir a quantidade de código Java repetitivo.</li>
        <li>spring-boot-starter-test: Dependência para o Spring Boot Test, que fornece suporte para escrever testes no projeto.</li>
        <li>jackson-databind: Dependência para o Jackson Databind, uma biblioteca para trabalhar com JSON em Java.</li>
<u>OpenAi api</u>
        <li>a api da openai foi usada para criar o chatbot</li>
        </ul>
      </article>
    </section>
</body>

</html>